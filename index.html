<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PotPlayer ChatGPT è¾…åŠ©é¢æ¿</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0e1117;
      --bg-card: rgba(17, 24, 39, 0.75);
      --bg-card-light: rgba(255, 255, 255, 0.85);
      --fg: #e6edf3;
      --fg-dark: #0f172a;
      --accent: #4f46e5;
      --accent-soft: rgba(79, 70, 229, 0.12);
      --border: rgba(148, 163, 184, 0.35);
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
      font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
    }

    html, body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, rgba(79, 70, 229, 0.15), transparent 50%),
        radial-gradient(circle at bottom, rgba(236, 72, 153, 0.1), transparent 45%),
        linear-gradient(180deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.7));
      background-color: #0f172a;
      color: var(--fg);
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: clamp(16px, 5vw, 48px);
    }

    header {
      width: min(1080px, 95vw);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 24px;
      margin-bottom: clamp(24px, 5vw, 48px);
      padding: clamp(16px, 3vw, 32px);
      border-radius: 28px;
      backdrop-filter: blur(18px);
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.28), rgba(30, 64, 175, 0.12));
      border: 1px solid rgba(99, 102, 241, 0.35);
      box-shadow: 0 20px 60px rgba(15, 23, 42, 0.55);
    }

    header h1 {
      margin: 0;
      font-size: clamp(26px, 4vw, 38px);
      font-weight: 700;
    }

    header p {
      margin: 6px 0 0;
      line-height: 1.6;
      max-width: 540px;
      font-size: clamp(14px, 2.5vw, 16px);
      color: rgba(226, 232, 240, 0.85);
    }

    main {
      width: min(1080px, 95vw);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: clamp(18px, 3vw, 28px);
    }

    .panel {
      position: relative;
      padding: clamp(18px, 3vw, 28px);
      border-radius: 24px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      backdrop-filter: blur(14px);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.45);
    }

    .panel.light {
      background: var(--bg-card-light);
      color: var(--fg-dark);
      border-color: rgba(148, 163, 184, 0.25);
    }

    .panel h2 {
      margin: 0 0 12px;
      font-size: clamp(20px, 3vw, 24px);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .panel h2 span {
      font-size: 24px;
    }

    .panel p {
      margin: 0 0 16px;
      line-height: 1.6;
      font-size: 15px;
      color: rgba(226, 232, 240, 0.8);
    }

    .panel.light p {
      color: rgba(15, 23, 42, 0.75);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 8px;
      color: rgba(226, 232, 240, 0.82);
    }

    .panel.light label {
      color: rgba(30, 41, 59, 0.8);
    }

    input[type="text"], input[type="url"], textarea, select {
      width: 100%;
      padding: 12px 16px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.4);
      color: inherit;
      font-size: 15px;
      transition: border 0.2s ease, box-shadow 0.2s ease;
      box-sizing: border-box;
    }

    .panel.light input[type="text"], .panel.light input[type="url"], .panel.light textarea, .panel.light select {
      background: rgba(255, 255, 255, 0.8);
      color: var(--fg-dark);
    }

    input[type="file"] {
      width: 100%;
      padding: 12px;
      border-radius: 14px;
      border: 1px dashed rgba(148, 163, 184, 0.45);
      background: rgba(15, 23, 42, 0.2);
      color: rgba(226, 232, 240, 0.85);
      cursor: pointer;
    }

    button {
      border: none;
      border-radius: 14px;
      padding: 12px 18px;
      font-weight: 600;
      font-size: 15px;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      transition: transform 0.15s ease, box-shadow 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.25);
      color: inherit;
    }

    button.danger {
      background: linear-gradient(135deg, #f97316, #ef4444);
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(99, 102, 241, 0.35);
    }

    textarea {
      min-height: 150px;
      resize: vertical;
    }

    .status-log {
      font-size: 14px;
      white-space: pre-wrap;
      line-height: 1.5;
      max-height: 320px;
      overflow-y: auto;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.3);
    }

    .panel.light .status-log {
      background: rgba(255, 255, 255, 0.7);
    }

    .portrait-wrapper {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 12px;
      border-radius: 22px;
      overflow: hidden;
      border: 1px dashed rgba(148, 163, 184, 0.35);
      min-height: 240px;
      background: rgba(15, 23, 42, 0.4);
    }

    .portrait-wrapper img {
      max-width: 100%;
      height: auto;
      display: block;
    }

    .portrait-fallback {
      text-align: center;
      color: rgba(226, 232, 240, 0.6);
      font-size: 14px;
      padding: 24px 12px;
    }

    .yolo-preview {
      display: grid;
      gap: 16px;
    }

    .yolo-canvas-wrapper {
      position: relative;
      width: 100%;
      border-radius: 20px;
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.25);
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
    }

    .chip-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(99, 102, 241, 0.22);
      font-size: 13px;
    }

    .chip strong {
      margin-right: 4px;
    }

    footer {
      margin-top: clamp(32px, 6vw, 48px);
      text-align: center;
      color: rgba(226, 232, 240, 0.55);
      font-size: 13px;
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        text-align: center;
      }

      .portrait-wrapper {
        min-height: 200px;
      }
    }

    @media (prefers-color-scheme: light) {
      body {
        background: linear-gradient(180deg, rgba(248, 250, 252, 0.95), rgba(241, 245, 249, 0.85));
        color: #0f172a;
      }

      header {
        background: linear-gradient(135deg, rgba(79, 70, 229, 0.12), rgba(129, 140, 248, 0.1));
        color: inherit;
      }

      .panel {
        background: rgba(255, 255, 255, 0.82);
        color: #0f172a;
        border-color: rgba(148, 163, 184, 0.3);
      }

      .status-log {
        background: rgba(248, 250, 252, 0.8);
        color: inherit;
      }

      label {
        color: rgba(30, 41, 59, 0.88);
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>PotPlayer ChatGPT äº‘ç«¯åŠ©æ‰‹</h1>
      <p>
        å°†å‰ç«¯æ•´åˆæˆå•ä¸€ <code>index.html</code> æ–¹ä¾¿éƒ¨ç½²è‡³ Cloudflare Pagesã€‚æœåŠ¡ç«¯ä»…è´Ÿè´£é«˜è´Ÿè½½çš„è¯­éŸ³è¯†åˆ«ä¸ YOLO ç›®æ ‡æ£€æµ‹ï¼Œ
        å…¶ä½™äº¤äº’å‡åœ¨æµè§ˆå™¨ç«¯å®Œæˆã€‚å¯åœ¨åŒç›®å½•æ”¾ç½®ç«‹ç»˜ä¸èƒŒæ™¯èµ„æºï¼Œè®©é¡µé¢æ›´å…·ä¸ªæ€§åŒ–ã€‚
      </p>
    </div>
    <div class="portrait-wrapper">
      <img id="character-portrait" src="./character.png" alt="åŠ©æ‰‹ç«‹ç»˜"
           onerror="this.style.display='none';document.getElementById('portrait-fallback').style.display='block';" />
      <div id="portrait-fallback" class="portrait-fallback" style="display:none;">
        å°†ç«‹ç»˜æ–‡ä»¶ï¼ˆå¦‚ <code>character.png</code>ï¼‰æ”¾åœ¨ä¸ <code>index.html</code> ç›¸åŒçš„ç›®å½•å³å¯åœ¨æ­¤æ˜¾ç¤ºã€‚
      </div>
    </div>
  </header>

  <main>
    <section class="panel light" aria-labelledby="connection-title">
      <h2 id="connection-title"><span>ğŸ”—</span> æœåŠ¡ç«¯è¿æ¥</h2>
      <p>é…ç½® Cloudflare Pages å‰ç«¯è¦è®¿é—®çš„åç«¯åœ°å€ã€‚è®¾ç½®ä¼šå­˜å‚¨åœ¨æµè§ˆå™¨çš„ <code>localStorage</code> ä¸­ã€‚</p>
      <div class="controls">
        <div>
          <label for="base-url">åç«¯åŸºåœ°å€</label>
          <input id="base-url" type="url" placeholder="https://your-api.example.com" autocomplete="url" />
        </div>
        <div>
          <label for="speech-endpoint">è¯­éŸ³è¯†åˆ« Endpoint</label>
          <input id="speech-endpoint" type="text" placeholder="/speech/transcribe" />
        </div>
        <div>
          <label for="yolo-endpoint">YOLO æ£€æµ‹ Endpoint</label>
          <input id="yolo-endpoint" type="text" placeholder="/vision/yolo" />
        </div>
        <div>
          <label for="api-key">å¯é€‰çš„ API Keyï¼ˆä¼šä¿å­˜åœ¨æµè§ˆå™¨ï¼‰</label>
          <input id="api-key" type="text" placeholder="å¦‚æœåç«¯éœ€è¦é‰´æƒå¯å¡«å…¥" autocomplete="off" />
        </div>
        <div class="chip-group">
          <span class="chip"><strong>POST</strong> è¯­éŸ³ï¼šFormData { file }</span>
          <span class="chip"><strong>POST</strong> YOLOï¼šFormData { file, confidence? }</span>
        </div>
        <div style="display:flex;gap:12px;flex-wrap:wrap;">
          <button id="save-settings" type="button">ğŸ’¾ ä¿å­˜è®¾ç½®</button>
          <button id="reset-settings" type="button" class="secondary">â™»ï¸ æ¢å¤é»˜è®¤</button>
        </div>
      </div>
    </section>

    <section class="panel" aria-labelledby="speech-title">
      <h2 id="speech-title"><span>ğŸ—£ï¸</span> è¯­éŸ³è¯†åˆ«</h2>
      <p>ä¸Šä¼ éŸ³é¢‘æˆ–ç›´æ¥å½•åˆ¶ï¼Œé€šè¿‡åç«¯ Whisper / Paraformer ç­‰æ¨¡å‹è¿›è¡Œè¯†åˆ«ã€‚</p>
      <div class="controls">
        <div>
          <label for="speech-file">ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶</label>
          <input id="speech-file" type="file" accept="audio/*,video/*" />
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <button id="send-speech" type="button">ğŸš€ å‘é€è¯†åˆ«è¯·æ±‚</button>
          <button id="record-toggle" type="button" class="secondary">ğŸ™ï¸ å¼€å§‹å½•éŸ³</button>
          <button id="cancel-speech" type="button" class="danger" disabled>â›” å–æ¶ˆè¿›è¡Œä¸­çš„è¯·æ±‚</button>
        </div>
        <div>
          <label for="speech-result">è¯†åˆ«ç»“æœ</label>
          <textarea id="speech-result" placeholder="è¯†åˆ«æ–‡æœ¬å°†åœ¨æ­¤å±•ç¤º" readonly></textarea>
        </div>
      </div>
    </section>

    <section class="panel" aria-labelledby="yolo-title">
      <h2 id="yolo-title"><span>ğŸ›°ï¸</span> YOLO ç›®æ ‡æ£€æµ‹</h2>
      <p>ä¸Šä¼ å›¾ç‰‡æˆ–è§†é¢‘å¸§ï¼Œç”±åç«¯è¿”å›æ£€æµ‹æ¡†ã€‚è‹¥åç«¯ç›´æ¥è¿”å›ç»˜åˆ¶å¥½çš„å›¾ç‰‡ï¼Œä¹Ÿä¼šè‡ªåŠ¨å±•ç¤ºã€‚</p>
      <div class="controls">
        <div>
          <label for="yolo-file">ä¸Šä¼ å›¾ç‰‡ / è§†é¢‘å¸§</label>
          <input id="yolo-file" type="file" accept="image/*" />
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <button id="send-yolo" type="button">ğŸ›°ï¸ å‘é€æ£€æµ‹è¯·æ±‚</button>
          <button id="cancel-yolo" type="button" class="danger" disabled>â›” å–æ¶ˆè¿›è¡Œä¸­çš„è¯·æ±‚</button>
        </div>
        <div>
          <label>æ£€æµ‹ç»“æœ</label>
          <div class="yolo-preview">
            <div class="yolo-canvas-wrapper">
              <canvas id="yolo-canvas" aria-label="ç›®æ ‡æ£€æµ‹é¢„è§ˆç”»å¸ƒ"></canvas>
            </div>
            <img id="yolo-image" alt="åç«¯è¿”å›çš„æ£€æµ‹å›¾ç‰‡" style="display:none;border-radius:20px;border:1px solid rgba(148,163,184,0.35);" />
            <div id="yolo-detections" class="status-log" style="max-height:200px;">
              ç­‰å¾…ä¸Šä¼ å›¾ç‰‡åå¼€å§‹æ£€æµ‹â€¦â€¦
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel light" aria-labelledby="log-title">
      <h2 id="log-title"><span>ğŸ“œ</span> çŠ¶æ€æ—¥å¿—</h2>
      <p>å®æ—¶å±•ç¤ºè¯·æ±‚çš„è¿›åº¦ä¸è°ƒè¯•ä¿¡æ¯ï¼Œä¾¿äºæ’æŸ¥ç½‘ç»œæˆ–é‰´æƒé—®é¢˜ã€‚</p>
      <div id="status-log" class="status-log" aria-live="polite">å‡†å¤‡å°±ç»ªï¼Œå°šæœªå‘èµ·è¯·æ±‚ã€‚</div>
    </section>
  </main>

  <footer>
    æ„å»ºä¸ºå•æ–‡ä»¶é¡µé¢ï¼Œå¯ç›´æ¥éƒ¨ç½²è‡³ Cloudflare Pagesã€‚è¯·ç¡®ä¿åŒç›®å½•ä¸‹èµ„æºå¯è¢«é™æ€æ‰˜ç®¡ã€‚
  </footer>

  <script>
    const dom = {
      baseUrl: document.getElementById('base-url'),
      speechEndpoint: document.getElementById('speech-endpoint'),
      yoloEndpoint: document.getElementById('yolo-endpoint'),
      apiKey: document.getElementById('api-key'),
      saveSettings: document.getElementById('save-settings'),
      resetSettings: document.getElementById('reset-settings'),
      speechFile: document.getElementById('speech-file'),
      sendSpeech: document.getElementById('send-speech'),
      cancelSpeech: document.getElementById('cancel-speech'),
      recordToggle: document.getElementById('record-toggle'),
      speechResult: document.getElementById('speech-result'),
      yoloFile: document.getElementById('yolo-file'),
      sendYolo: document.getElementById('send-yolo'),
      cancelYolo: document.getElementById('cancel-yolo'),
      yoloCanvas: document.getElementById('yolo-canvas'),
      yoloImage: document.getElementById('yolo-image'),
      yoloDetections: document.getElementById('yolo-detections'),
      statusLog: document.getElementById('status-log'),
    };

    const STORAGE_KEY = 'potplayer-cloudflare-settings';
    const DEFAULT_SETTINGS = {
      baseUrl: '',
      speechEndpoint: '/speech/transcribe',
      yoloEndpoint: '/vision/yolo',
      apiKey: '',
    };

    let speechController = null;
    let yoloController = null;
    let mediaRecorder = null;
    let recordedChunks = [];

    function loadSettings() {
      try {
        const settings = JSON.parse(localStorage.getItem(STORAGE_KEY)) || DEFAULT_SETTINGS;
        Object.assign(DEFAULT_SETTINGS, settings);
        dom.baseUrl.value = settings.baseUrl ?? DEFAULT_SETTINGS.baseUrl;
        dom.speechEndpoint.value = settings.speechEndpoint ?? DEFAULT_SETTINGS.speechEndpoint;
        dom.yoloEndpoint.value = settings.yoloEndpoint ?? DEFAULT_SETTINGS.yoloEndpoint;
        dom.apiKey.value = settings.apiKey ?? DEFAULT_SETTINGS.apiKey;
      } catch (error) {
        console.error('æ— æ³•åŠ è½½è®¾ç½®', error);
      }
    }

    function saveSettings() {
      const settings = {
        baseUrl: dom.baseUrl.value.trim(),
        speechEndpoint: dom.speechEndpoint.value.trim() || DEFAULT_SETTINGS.speechEndpoint,
        yoloEndpoint: dom.yoloEndpoint.value.trim() || DEFAULT_SETTINGS.yoloEndpoint,
        apiKey: dom.apiKey.value.trim(),
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      logStatus('è®¾ç½®å·²ä¿å­˜ã€‚', 'success');
      return settings;
    }

    function resetSettings() {
      localStorage.removeItem(STORAGE_KEY);
      dom.baseUrl.value = DEFAULT_SETTINGS.baseUrl;
      dom.speechEndpoint.value = DEFAULT_SETTINGS.speechEndpoint;
      dom.yoloEndpoint.value = DEFAULT_SETTINGS.yoloEndpoint;
      dom.apiKey.value = DEFAULT_SETTINGS.apiKey;
      logStatus('å·²æ¢å¤é»˜è®¤è®¾ç½®ã€‚', 'info');
    }

    function getSettings() {
      return {
        baseUrl: dom.baseUrl.value.trim(),
        speechEndpoint: dom.speechEndpoint.value.trim() || DEFAULT_SETTINGS.speechEndpoint,
        yoloEndpoint: dom.yoloEndpoint.value.trim() || DEFAULT_SETTINGS.yoloEndpoint,
        apiKey: dom.apiKey.value.trim(),
      };
    }

    function buildUrl(base, endpoint) {
      if (!endpoint.startsWith('/') && !base.endsWith('/')) {
        return base + '/' + endpoint;
      }
      return base + endpoint;
    }

    function logStatus(message, type = 'info') {
      const time = new Date().toLocaleTimeString();
      const color = {
        success: 'var(--success)',
        warning: 'var(--warning)',
        danger: 'var(--danger)',
        error: 'var(--danger)',
        info: 'var(--accent)'
      }[type] || 'var(--accent)';
      const entry = document.createElement('div');
      entry.innerHTML = `<span style="color:${color};font-weight:600;">[${time}]</span> ${message}`;
      dom.statusLog.prepend(entry);
      dom.statusLog.scrollTop = 0;
    }

    function applyLoadingState(target, loading, textWhileLoading) {
      if (!target.dataset.originalText) {
        target.dataset.originalText = target.innerHTML;
      }
      target.disabled = loading;
      target.innerHTML = loading ? textWhileLoading : target.dataset.originalText;
    }

    async function sendFormData(url, formData, { signal, expect = 'json', headers = {} } = {}) {
      const response = await fetch(url, {
        method: 'POST',
        body: formData,
        headers,
        signal,
      });

      if (!response.ok) {
        const text = await response.text();
        throw new Error(`HTTP ${response.status}: ${text.slice(0, 180)}`);
      }

      if (expect === 'blob') {
        return await response.blob();
      }
      if (expect === 'text') {
        return await response.text();
      }
      return await response.json();
    }

    async function handleSpeechUpload(file, filename = null) {
      const settings = getSettings();
      if (!settings.baseUrl) {
        logStatus('è¯·å…ˆåœ¨â€œæœåŠ¡ç«¯è¿æ¥â€é¢æ¿ä¸­å¡«å†™åç«¯åœ°å€ã€‚', 'warning');
        return;
      }
      if (!file) {
        logStatus('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å…ˆå¼€å§‹å½•éŸ³ã€‚', 'warning');
        return;
      }

      if (speechController) {
        speechController.abort();
      }
      speechController = new AbortController();
      const url = buildUrl(settings.baseUrl, settings.speechEndpoint);
      const formData = new FormData();
      formData.append('file', file, filename || file.name);

      const headers = {};
      if (settings.apiKey) {
        headers['Authorization'] = `Bearer ${settings.apiKey}`;
      }

      applyLoadingState(dom.sendSpeech, true, 'â³ è¯†åˆ«ä¸­â€¦');
      dom.cancelSpeech.disabled = false;
      logStatus(`å¼€å§‹è¯­éŸ³è¯†åˆ«ï¼š${formData.get('file').name}`, 'info');

      try {
        const result = await sendFormData(url, formData, { signal: speechController.signal, headers });
        renderSpeechResult(result);
        logStatus('è¯­éŸ³è¯†åˆ«å®Œæˆã€‚', 'success');
      } catch (error) {
        if (speechController.signal.aborted) {
          logStatus('è¯­éŸ³è¯†åˆ«è¯·æ±‚å·²å–æ¶ˆã€‚', 'warning');
        } else {
          console.error(error);
          logStatus(`è¯­éŸ³è¯†åˆ«å¤±è´¥ï¼š${error.message}`, 'error');
        }
      } finally {
        applyLoadingState(dom.sendSpeech, false);
        dom.cancelSpeech.disabled = true;
        speechController = null;
      }
    }

    function renderSpeechResult(result) {
      if (!result) {
        dom.speechResult.value = 'æœªä»åç«¯è·å–åˆ°ä»»ä½•å†…å®¹ã€‚';
        return;
      }

      if (typeof result === 'string') {
        dom.speechResult.value = result;
        return;
      }

      if (result.text) {
        dom.speechResult.value = result.text;
      } else if (result.transcript) {
        dom.speechResult.value = result.transcript;
      } else if (Array.isArray(result.segments)) {
        const combined = result.segments.map(seg => seg.text || JSON.stringify(seg)).join('\n');
        dom.speechResult.value = combined;
      } else {
        dom.speechResult.value = JSON.stringify(result, null, 2);
      }
    }

    async function handleYoloUpload(file) {
      const settings = getSettings();
      if (!settings.baseUrl) {
        logStatus('è¯·å…ˆåœ¨â€œæœåŠ¡ç«¯è¿æ¥â€é¢æ¿ä¸­å¡«å†™åç«¯åœ°å€ã€‚', 'warning');
        return;
      }
      if (!file) {
        logStatus('è¯·é€‰æ‹©éœ€è¦æ£€æµ‹çš„å›¾ç‰‡ã€‚', 'warning');
        return;
      }

      if (yoloController) {
        yoloController.abort();
      }
      yoloController = new AbortController();
      const url = buildUrl(settings.baseUrl, settings.yoloEndpoint);
      const formData = new FormData();
      formData.append('file', file, file.name);

      const headers = {};
      if (settings.apiKey) {
        headers['Authorization'] = `Bearer ${settings.apiKey}`;
      }

      applyLoadingState(dom.sendYolo, true, 'ğŸ›°ï¸ æ£€æµ‹ä¸­â€¦');
      dom.cancelYolo.disabled = false;
      logStatus(`å¼€å§‹ YOLO æ£€æµ‹ï¼š${file.name}`, 'info');

      try {
        const result = await sendFormData(url, formData, { signal: yoloController.signal, headers });
        await renderYoloResult(result, file);
        logStatus('YOLO æ£€æµ‹å®Œæˆã€‚', 'success');
      } catch (error) {
        if (yoloController.signal.aborted) {
          logStatus('YOLO æ£€æµ‹è¯·æ±‚å·²å–æ¶ˆã€‚', 'warning');
        } else {
          console.error(error);
          logStatus(`YOLO æ£€æµ‹å¤±è´¥ï¼š${error.message}`, 'error');
        }
      } finally {
        applyLoadingState(dom.sendYolo, false);
        dom.cancelYolo.disabled = true;
        yoloController = null;
      }
    }

    async function renderYoloResult(result, originalFile) {
      dom.yoloImage.style.display = 'none';
      dom.yoloDetections.textContent = '';

      let detections = [];
      if (!result) {
        dom.yoloDetections.textContent = 'åç«¯è¿”å›ä¸ºç©ºã€‚';
      } else if (Array.isArray(result)) {
        detections = result;
      } else if (result.detections) {
        detections = result.detections;
      }

      if (result && result.image) {
        dom.yoloImage.src = result.image.startsWith('data:') ? result.image : `data:image/png;base64,${result.image}`;
        dom.yoloImage.style.display = 'block';
      }

      if (detections.length) {
        dom.yoloDetections.textContent = '';
        detections.forEach((item, index) => {
          const div = document.createElement('div');
          const conf = item.confidence ?? item.score ?? 0;
          const box = item.box || item.bbox || item.boundingBox;
          div.innerHTML = `<strong>#${index + 1}</strong> ${item.label || item.class || 'æœªå‘½åç›®æ ‡'} - ${(conf * 100).toFixed(1)}%`;
          if (box) {
            div.innerHTML += `<br /><small>box: ${Array.isArray(box) ? box.join(', ') : JSON.stringify(box)}</small>`;
          }
          dom.yoloDetections.appendChild(div);
        });
      } else if (!result || !result.image) {
        dom.yoloDetections.textContent = 'åç«¯æ²¡æœ‰è¿”å› detections åˆ—è¡¨ã€‚';
      }

      drawDetectionsOnCanvas(detections, originalFile);
    }

    function drawDetectionsOnCanvas(detections, originalFile) {
      const canvas = dom.yoloCanvas;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return;
      }

      const img = new Image();
      const objectURL = URL.createObjectURL(originalFile);
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        if (Array.isArray(detections) && detections.length) {
          ctx.lineWidth = Math.max(2, Math.min(canvas.width, canvas.height) / 200);
          ctx.font = `${Math.max(12, canvas.width / 40)}px sans-serif`;
          detections.forEach(det => {
            const box = det.box || det.bbox || det.boundingBox;
            if (!box) return;
            let [x, y, w, h] = Array.isArray(box) ? box : [box.x, box.y, box.width || box.w, box.height || box.h];
            if (box.xmin !== undefined) {
              x = box.xmin;
              y = box.ymin;
              w = (box.xmax ?? x) - x;
              h = (box.ymax ?? y) - y;
            }
            if ([x, y, w, h].some(v => typeof v !== 'number')) {
              return;
            }
            ctx.strokeStyle = '#22d3ee';
            ctx.fillStyle = 'rgba(34, 211, 238, 0.25)';
            ctx.strokeRect(x, y, w, h);
            ctx.fillRect(x, y, w, h);
            const label = det.label || det.class || 'Object';
            const score = det.confidence ?? det.score;
            const text = score ? `${label} ${(score * 100).toFixed(1)}%` : label;
            const textWidth = ctx.measureText(text).width;
            const padding = 6;
            ctx.fillStyle = 'rgba(15, 23, 42, 0.85)';
            ctx.fillRect(x, Math.max(0, y - 24), textWidth + padding * 2, 24);
            ctx.fillStyle = '#f8fafc';
            ctx.fillText(text, x + padding, Math.max(16, y - 8));
          });
        }
        URL.revokeObjectURL(objectURL);
      };
      img.onerror = () => {
        URL.revokeObjectURL(objectURL);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        dom.yoloDetections.textContent = 'æ— æ³•è¯»å–åŸå§‹å›¾ç‰‡ï¼Œå¯èƒ½æ˜¯æµè§ˆå™¨ä¸æ”¯æŒçš„æ ¼å¼ã€‚';
      };
      img.src = objectURL;
    }

    function setupRecording() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        dom.recordToggle.disabled = true;
        dom.recordToggle.textContent = 'æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³';
        logStatus('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ MediaRecorderã€‚', 'warning');
        return;
      }

      dom.recordToggle.addEventListener('click', async () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
          return;
        }
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          recordedChunks = [];

          mediaRecorder.ondataavailable = event => {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = () => {
            dom.recordToggle.innerHTML = 'ğŸ™ï¸ å¼€å§‹å½•éŸ³';
            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
            const file = new File([blob], `recording_${Date.now()}.webm`, { type: blob.type });
            handleSpeechUpload(file, file.name);
            stream.getTracks().forEach(track => track.stop());
          };

          mediaRecorder.start();
          dom.recordToggle.innerHTML = 'â¹ï¸ åœæ­¢å½•éŸ³';
          logStatus('å¼€å§‹å½•éŸ³ï¼Œå®Œæˆåè‡ªåŠ¨å‘é€è¯†åˆ«ã€‚', 'info');
        } catch (error) {
          console.error(error);
          logStatus(`æ— æ³•å¯åŠ¨å½•éŸ³ï¼š${error.message}`, 'error');
        }
      });
    }

    function bindEvents() {
      dom.saveSettings.addEventListener('click', saveSettings);
      dom.resetSettings.addEventListener('click', resetSettings);
      dom.sendSpeech.addEventListener('click', () => handleSpeechUpload(dom.speechFile.files[0]));
      dom.sendYolo.addEventListener('click', () => handleYoloUpload(dom.yoloFile.files[0]));
      dom.cancelSpeech.addEventListener('click', () => {
        if (speechController) {
          speechController.abort();
        }
      });
      dom.cancelYolo.addEventListener('click', () => {
        if (yoloController) {
          yoloController.abort();
        }
      });
      setupRecording();
    }

    loadSettings();
    bindEvents();
    logStatus('å‰ç«¯åˆå§‹åŒ–å®Œæˆã€‚', 'success');
  </script>
</body>
</html>
